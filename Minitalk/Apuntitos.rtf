{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Bold;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fswiss\fcharset0 Arial-BoldMT;\f4\froman\fcharset0 Times-Roman;\f5\fswiss\fcharset0 ArialMT;
\f6\fswiss\fcharset0 Helvetica-Bold;\f7\fnil\fcharset0 Menlo-Italic;\f8\froman\fcharset0 Times-Bold;
\f9\fnil\fcharset0 LucidaGrande;\f10\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red14\green14\blue14;\red245\green245\blue245;\red0\green0\blue0;
\red26\green26\blue26;\red0\green0\blue0;\red255\green255\blue255;\red38\green38\blue38;}
{\*\expandedcolortbl;;\cssrgb\c6667\c6667\c6667;\cssrgb\c96863\c96863\c96863;\cssrgb\c0\c0\c0;
\cssrgb\c13333\c13333\c13333;\csgray\c0\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c20000\c20000\c20000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid101\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid102\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww27740\viewh17360\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 NOTAS MiniTalk\
\
\
* Puedes usar una var global por programa\
\
*Funciones permitidas definidas:\
\
	
\f1\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
sigemptyset	
\f2\b0 Inicia  el conjunto de se\'f1ales dado por \ul conjunto\ulnone  al conjunto vac\'edo, con todas las se\'f1ales fuera del conjunto.
\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
	\
				
\f1\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
int
\f2\b0  
\f1\b sigfillset(sigset_t
\f2\b0  
\f1\b *
\f2\b0 \ul conjunto
\f1\b \ulnone );\
\
\
				
\f3\fs32 \cf4 \cb1 \outl0\strokewidth0 \strokec4 sigemptyset 
\f4\b0\fs24 \
\pard\pardeftab720\fi4563\sa240\partightenfactor0

\f5\fs32 \cf4 Pone a cero todo el conjunto de se\'f1ales. En el caso general utiliza la instrucci\'f3n 
\f3\b memset 
\f5\b0 para poner ceros en set. Cuando 
\f3\b _NSIG_WORDS 
\f5\b0 vale 1 (palabras de 2 						   bytes) directamente pone a uno. 
\f4\fs24 \

\f5\fs32 extern inline void 
\f3\b sigemptyset 
\f5\b0 ( sigset_t *set ) \{ 
\f4\fs24 \

\f5\fs32 switch (_NSIG_WORDS) \{ \
	default: 
\f4\fs24 \

\f5\fs32 	memset(set, 0, sizeof(sigset_t)); 
\f4\fs24 \

\f5\fs32 	break;\uc0\u8232 							case2: set->sig[1]=0; case 1: set -> sig [0] = 0; 
\f4\fs24 \

\f5\fs32 	break; \
\} 
\f4\fs24 \

\f5\fs32 \} 
\f4\fs24 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs28 \cf2 \cb3 \outl0\strokewidth0 \
\
	sigaddset
\f2\b0  y 
\f1\b sigdelset:
\f2\b0 	a\'f1aden y quitan respectivamente la se\'f1al \ul numse\ulnone  de \ul conjunto\ulnone .\
						 	
\f1\b int
\f2\b0  
\f1\b sigaddset(sigset_t
\f2\b0  
\f1\b *
\f2\b0 \ul conjunto
\f1\b \ulnone ,
\f2\b0  
\f1\b int
\f2\b0  \ul numse
\f1\b \ulnone );\
\
							
\f3\fs32 \cf4 \cb1 \outl0\strokewidth0 \strokec4 sigaddset \

\f4\b0\fs24 \
\pard\pardeftab720\li4966\fi21\sa240\partightenfactor0

\f5\fs32 \cf4 A\'f1ade una se\'f1al a un conjunto, poniendo a uno el bit correspondiente. 
\f4\fs24 \

\f5\fs32 extern inline void 
\f3\b sigaddset 
\f5\b0 (sigset_t *set, int _sig) 
\f4\fs24 \

\f5\fs32 \{\uc0\u8232 /* resta uno a la se\'f1al, el indice del vector comienza en cero */ 
\f4\fs24 \

\f5\fs32 unsigned long sig = _sig - 1; 
\f4\fs24 \

\f5\fs32 if (_NSIG_WORDS == 1) /* tama\'f1o de la palabra unsigned long*/ set->sig[0] |= 1UL << sig; 
\f4\fs24 \

\f5\fs32 else 
\f4\fs24 \

\f5\fs32 /* ajustar el indice dividiendo por NSIG_BPW bits por palabra */ set->sig[sig/_NSIG_BPW] |= 1UL << (sig % _NSIG_BPW); 
\f4\fs24 \

\f5\fs32 \} \
\pard\pardeftab720\fi4872\sa240\partightenfactor0

\f3\b \cf4 sigaddset\uc0\u8232 
\f5\b0 										Utiliza la instrucci\'f3n 
\f3\b btsl 
\f5\b0 para poner un bit a uno en su operando. 
\f4\fs24 \

\f5\fs32 extern __inline__ void 
\f3\b sigaddset 
\f5\b0 (sigset_t *set, int _sig) \
\{ 
\f4\fs24 \

\f5\fs32 		__asm__("btsl%1,%0" : "=m"(*set) :"ir"(_sig-1) : "cc"); 
\f4\fs24 \

\f5\fs32 \} 
\f4\fs24 \
\pard\pardeftab720\li4966\fi21\sa240\partightenfactor0
\cf4 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b\fs28 \cf2 \cb3 \outl0\strokewidth0 \
\
	sigaction  	
\f2\b0 La  llamad  al  sistema  
\f1\b sigaction
\f2\b0   se emplea para cambiar la acci\'f3n tomada por un proceso\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3        			cuando recibe una determinada se\'f1al.
\f1\b \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf2 \cb3 				int
\f2\b0  
\f1\b sigaction(int
\f2\b0  \ul signum
\f1\b \ulnone ,
\f2\b0  
\f1\b const
\f2\b0  
\f1\b struct
\f2\b0  
\f1\b sigaction
\f2\b0  
\f1\b *
\f2\b0 \ul act
\f1\b \ulnone ,
\f2\b0  
\f1\b struct
\f2\b0  
\f1\b sigaction
\f2\b0  
\f1\b *
\f2\b0 \ul oldact
\f1\b \ulnone );\
\
	
\f2\b0  
\f1\b getpid
\f2\b0 		devuelve el identificador de proceso del proceso actual. (Esto es usado normalmente\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3        			por rutinas que generan nombres \'fanicos  de  ficheros  temporales.)   
\f1\b getppid
\f2\b0   devuelve  el\
       			identificador de proceso del padre del proceso actual.\
\
	
\f6\b \cf5 \cb1 sleep 
\f0\b0 		duerme durante el n\'famero de segundos especificado\
				
\f1\b \cf5 \cb6 unsigned int sleep(unsigned int 
\f7\i\b0 segundos
\f1\i0\b );\
	\
	usleep		
\f2\b0 \cf2 \cb3 Suspende la ejecuci\'f3n durante un intervalo de varios microsegundos.\
				La funci\'f3n 
\f1\b usleep()
\f2\b0  suspende la ejecuci\'f3n del proceso llamante durante \cf2 \cb3 \ul \ulc2 usec\cf2 \cb3 \ulnone  microsegundos.\
       			La pausa puede prolongarse ligeramente por cualquier actividad en  el  sistema  o  por  el\
       			tiempo gastado procesando la llamada.\
				
\f1\b void
\f2\b0  
\f1\b usleep(unsigned
\f2\b0  
\f1\b long
\f2\b0  \cf2 \cb3 \ul \ulc2 usec
\f1\b \cf2 \cb3 \ulnone );\
\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320\partightenfactor0
\ls1\ilvl0
\f4\b0\fs32 \cf4 \cb1 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Debes crear un programa de comunicaci\'f3n en la forma de un 
\f8\b cliente 
\f4\b0 y un 
\f8\b servidor
\f4\b0 . \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 El servidor debe lanzarse primero, tras lanzarse debe mostrar su PID. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 El cliente tomar\'e1 como par\'e1metros: \uc0\u8232 
\f9 \uc0\u9702 
\f4  El PID del servidor.\uc0\u8232 
\f9 \uc0\u9702 
\f4  La string que deber\'eda mandarse. \
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 El cliente debe comunicar la string pasada como par\'e1metro al servidor. Una vez la string se haya recibido, el servidor debe mostrarla. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 El servidor debe ser capaz de mostrar la string suficientemente r\'e1pido. Por r\'e1pido queremos decir que si piensas que es est\'e1 tardando mucho, probablemente es que est\'e1 tardando demasiado. \uc0\u8232 
\f8\b NOTA 1 segundo para mostrar 100 caracteres es demasiado
\f4\b0 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Solo puedes utilizar estas dos se\'f1ales:
\f8\b  SIGUSR1 
\f4\b0 y
\f8\b  SIGUSR2.  ( tener en cuenta que cada se\'f1al env\'eda un bits y que cada caracteres tiene 8 bits) entiendo que en el cliente se van pasando a binarios \
\ls1\ilvl0
\f4\b0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		y se env\'eda la se\'f1al de cada bits al server , que tendr\'e1 que hacer el proceso inverso de traducir cada 8 bits al car\'e1cter correspondiente.\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \uc0\u8232 \u8232 \
\pard\pardeftab720\li1432\fi-1433\partightenfactor0

\f1\b\fs28 \cf5 \cb6 \outl0\strokewidth0 PID		
\f0\b0\fs30 \cf0 \cb7 PID (Process ID o ID de proceso o identificador de procesos) es un n\'famero entero usado por el kernel de algunos sistemas operativos (como el de Unix o el de Windows NT) para identificar un proceso de forma un\'edvoca.\cb1 \
\pard\pardeftab720\li1432\fi-1433\sa480\partightenfactor0
\cf0 \cb7 		\
		Para asignar el PID, el kernel utiliza internamente una variable global que se va incrementando con cada nuevo proceso creado con una llamada fork(). Cuando la variable alcanza un cierto valor l\'edmite se empieza otra vez desde 0, buscando n\'fameros que no est\'e9n asignados ya a otro proceso en ejecuci\'f3n.\cb1 \
\cb7 		El valor 0 del PID est\'e1 reservado a la tarea ociosa del sistema, un proceso que se crea al arrancar el sistema y nunca puede finalizar.\cb1 \
\pard\pardeftab720\li1432\fi-1433\partightenfactor0
\cf0 \cb7 		Las versiones antiguas de Linux permit\'edan que dos procesos compartieran el mismo PID. Actualmente esto s\'f3lo se permite en un sistema multiprocesador en el que varias CPUs ejecuten distintas instancias de la tarea ociosa; en este caso, todas las instancias tendr\'e1n asignado PID 0.
\f1\b\fs28 \cf5 \cb6 \
	\
NOTAS\
		\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls2\ilvl1\cf5 \kerning1\expnd0\expndtw0 {\listtext	
\f10\b0 \uc0\u8259 
\f1\b 	}
\f5\b0\fs32 \cf4 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Cada bit corresponde a una se\'f1al. \
\ls2\ilvl1
\f4\fs24 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f9 \uc0\u8259 
\f4 	}
\f3\b\fs32 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 sigaction 
\f5\b0 contiene la acci\'f3n a tomar por un proceso cuando se recibe una se\'f1al 
\f4\fs24 \
\ls2\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f9 \uc0\u8259 
\f4 	}
\f8\b\fs36 pause().   
\f0\b0\fs28 \cf8 \expnd0\expndtw0\kerning0
Cuando queremos que un proceso espere a que le llegue una se\'f1al, usaremos la funci\'f3n pause(). Esta funci\'f3n provoca que el proceso (o thread) en cuesti\'f3n \'93duerma\'94 hasta que le llegue una se\'f1al. Para capturar esa se\'f1al, el proceso deber\'e1 haber establecido un tratamiento de la misma con la funci\'f3n signal(
\f4\fs24 \cf4 \outl0\strokewidth0 \strokec4 \
\pard\pardeftab720\li1432\fi-1433\partightenfactor0

\f1\b\fs28 \cf5 \cb6 \outl0\strokewidth0 \
\
 		DESARROLLO\
\
1 Crear Makefile que compile ambos programas ( cliente servidor e indique nombre correcto de los ejecutables : client y server) \
\
}